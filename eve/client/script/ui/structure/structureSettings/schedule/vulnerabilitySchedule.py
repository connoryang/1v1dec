#Embedded file name: e:\jenkins\workspace\client_SERENITY\branches\release\SERENITY\eve\client\script\ui\structure\structureSettings\schedule\vulnerabilitySchedule.py
from collections import defaultdict
import itertools
from operator import itemgetter
from carbonui.primitives.container import Container
from carbonui.primitives.fill import Fill
from carbonui.primitives.frame import Frame
from carbonui.primitives.gridcontainer import GridContainer
from carbonui.primitives.line import Line
from carbonui.primitives.sprite import Sprite
from carbonui.util.color import Color
from eve.client.script.ui.control.eveLabel import EveLabelMedium, EveLabelSmall
import carbonui.const as uiconst
from eve.client.script.ui.control.themeColored import FrameThemeColored, FillThemeColored, SpriteThemeColored
import itertoolsext
from localization import GetByLabel
import structures
import uthread
import trinity
import blue

class VulnerabilityScheduler(Container):
    default_align = uiconst.TOALL
    default_name = 'VulnerabilityScheduler'
    default_state = uiconst.UI_NORMAL
    DAY_COLUMN_HEIGHT = 20
    shortDayNamesPaths = ['UI/StructureProfiles/MondayShort',
     'UI/StructureProfiles/TuesdayShort',
     'UI/StructureProfiles/WednesdayShort',
     'UI/StructureProfiles/ThursdayShort',
     'UI/StructureProfiles/FridayShort',
     'UI/StructureProfiles/SaturdayShort',
     'UI/StructureProfiles/SundayShort']

    def ApplyAttributes(self, attributes):
        Container.ApplyAttributes(self, attributes)
        if attributes.schedule:
            self.mySchedule = attributes.schedule
            self.requiredHours = self.mySchedule.GetRequiredHours()
        elif attributes.requiredHours:
            self.requiredHours = attributes.requiredHours
            self.mySchedule = structures.Schedule(required=self.requiredHours)
        else:
            raise RuntimeError('VulnerabilityScheduler - neither schedule nor required hours?')
        self.callback = attributes.callback
        self.unallocatedCont = None
        self.remainingLabel = None
        self.timeConts = []
        self.showDay = attributes.get('showDay', True)
        self.showTime = attributes.get('showTime', True)
        self.canModify = attributes.get('canModify', True)
        self.dragStart = None
        self.dragContainer = None
        self.dragMouseBtn = None
        self.hourConts = defaultdict(dict)
        self.MakeUnallocatedStrip()
        if attributes.get('frame', True):
            Frame(parent=self, color=(1, 1, 1, 0.5))
        self.MakeGrid()
        self.AddBackgroundImage()
        self.ColorBoxes()
        self.UpdateHourFill()
        self.UpdateView()

    def AddBackgroundImage(self):
        self.backgroundImage = SpriteThemeColored(name='backgroundImage', parent=self.weekContParent, state=uiconst.UI_DISABLED, colorType=uiconst.COLORTYPE_UIHILIGHTGLOW, spriteEffect=trinity.TR2_SFX_BLUR, blendMode=trinity.TR2_SBM_ADDX2, texturePath='res:/UI/Texture/classes/StructureDeployment/deploymentBg.png', opacity=0.02, align=uiconst.CENTER)

    def MakeUnallocatedStrip(self):
        padTop = self.DAY_COLUMN_HEIGHT if self.showDay else 0
        self.bottomCont = Container(parent=self, align=uiconst.TOBOTTOM, height=8, padTop=8)
        if not self.canModify:
            return
        if self.showDay:
            remainingCont = Container(parent=self.bottomCont, align=uiconst.TORIGHT, width=40)
            self.remainingLabel = EveLabelSmall(parent=remainingCont, align=uiconst.CENTER, text='')
        self.unallocatedCont = UnallocatedCont(name='unallocatedCont', parent=self.bottomCont, columns=self.requiredHours, requiredHours=self.requiredHours, schedule=self.mySchedule, padRight=4)
        self.UpdateUnallocatedCounter()

    def MakeGrid(self):
        if self.showTime:
            padTop = self.DAY_COLUMN_HEIGHT if self.showDay else 0
            hourCont = GridContainer(name='hourCont', parent=self, align=uiconst.TOLEFT, width=50, columns=1, lines=24, padTop=padTop)
            for x in xrange(24):
                c = Container(parent=hourCont)
                self.timeConts.append(c)

        if self.showDay:
            dayCont = GridContainer(name='dayCont', parent=self, align=uiconst.TOTOP, columns=7, height=self.DAY_COLUMN_HEIGHT)
            for eachDayPath in self.shortDayNamesPaths:
                c = Container(parent=dayCont)
                text = GetByLabel(eachDayPath)
                EveLabelMedium(parent=c, align=uiconst.CENTER, text=text)

        self.weekContParent = Container(name='weekContParent', parent=self, align=uiconst.TOALL)
        self.weekCont = GridContainer(name='weekCont', parent=self.weekContParent, align=uiconst.TOALL, columns=7)
        self.hourConts.clear()
        for hour in xrange(24):
            for day in xrange(7):
                c = HourContWithReinforcement(parent=self.weekCont, name='%s_%s' % (day, hour), dayHour=(day, hour), hint='%s<br>%s' % (GetByLabel(self.shortDayNamesPaths[day]), '%.2d:00' % hour), parentMouseDown=self.OnMouseDown)
                self.hourConts[day][hour] = c

        self.DecorateGrid()

    def DecorateGrid(self):
        lineColor = (1.0, 1.0, 1.0, 0.2)
        interval = 2
        firstCol = True
        for i, c in enumerate(self.timeConts):
            self._DecorateCell(c, i, interval, lineColor, firstCol=True)
            if i % interval == 0:
                EveLabelSmall(parent=c, align=uiconst.CENTERTOP, text='%.2d:00' % i, top=1)
            firstCol = False

        for dayHour, hourCont in self.GetDayHourIterator():
            day, hour = dayHour
            firstCol = firstCol and day == 0
            self._DecorateCell(hourCont, hour, interval, lineColor, firstCol)

    def _DecorateCell(self, cell, hour, interval, lineColor, firstCol = False):
        Line(parent=cell, align=uiconst.TORIGHT, color=lineColor)
        if firstCol:
            Line(parent=cell, align=uiconst.TOLEFT, color=lineColor)
        if hour == 23:
            Line(parent=cell, align=uiconst.TOBOTTOM, color=lineColor)
        if hour % interval == 0:
            Line(parent=cell, align=uiconst.TOTOP, color=lineColor)

    def OnMouseDown(self, *args):
        if not self.canModify:
            return
        if self.dragMouseBtn is not None:
            return
        if args[0] in (uiconst.MOUSELEFT, uiconst.MOUSERIGHT):
            self.dragMouseBtn = args[0]
        else:
            return
        self.dragStart = (uicore.uilib.x - self.weekCont.absoluteLeft, uicore.uilib.y - self.weekCont.absoluteTop)
        self.previousSchedule = self.mySchedule.Copy()
        if self.dragContainer is None or self.dragContainer.destroyed:
            self.MakeDragContainer()
        self.dragContainer.Hide()
        uthread.new(self.RubberbandSelection_thread)

    def MakeDragContainer(self):
        self.dragContainer = Container(parent=self.weekContParent, align=uiconst.TOPLEFT, idx=0)
        FrameThemeColored(parent=self.dragContainer, frameConst=uiconst.FRAME_BORDER1_CORNER3, colorType=uiconst.COLORTYPE_UIHILIGHT, opacity=0.5)
        FillThemeColored(parent=self.dragContainer, frameConst=uiconst.FRAME_FILLED_CORNER3, opacity=0.3)

    def RubberbandSelection_thread(self, *args):
        counter = 0
        while self.dragMouseBtn is not None and uicore.uilib.GetMouseButtonState(self.dragMouseBtn) and trinity.app.IsActive():
            self.RubberbandWhileLoop()
            blue.pyos.synchro.SleepSim(10)
            if counter % 10 == 0:
                self.TryCallback()
            counter += 1

        self.dragStart = None
        self.dragContainer.Hide()
        self.dragMouseBtn = None
        self.TryCallback()

    def TryCallback(self):
        if self.callback:
            self.callback(self.mySchedule)

    def RubberbandWhileLoop(self):
        startX, startY = self.dragStart
        currentX, currentY = uicore.uilib.x - self.weekCont.absoluteLeft, uicore.uilib.y - self.weekCont.absoluteTop
        if startX > currentX:
            temp = currentX
            currentX = startX
            startX = temp
        if startY > currentY:
            temp = currentY
            currentY = startY
            startY = temp
        left = max(startX, 0)
        mainWidth = self.weekCont.absoluteRight - self.weekCont.absoluteLeft
        width = min(currentX, mainWidth) - max(startX, 0)
        top = max(startY, 0)
        mainHeight = self.weekCont.absoluteBottom - self.weekCont.absoluteTop
        height = min(currentY, mainHeight) - max(startY, 0)
        self.dragContainer.left = left
        self.dragContainer.top = top
        self.dragContainer.width = width
        self.dragContainer.height = height
        self.dragContainer.Show()
        self.FindSelected(startX, startY, currentX, currentY)
        self.UpdateView()

    def UpdateView(self):
        self.ColorBoxes()
        if self.unallocatedCont:
            self.unallocatedCont.Update()
            self.UpdateUnallocatedCounter()
        self.UpdateHourFill()

    def UpdateUnallocatedCounter(self):
        if self.remainingLabel is None:
            return
        remaining = self.mySchedule.Remaining()
        total = self.mySchedule.GetRequiredHours()
        text = '%s / %s' % (remaining, total)
        if remaining == 0:
            color = Color.GREEN
        elif remaining > 0:
            color = Color.YELLOW
        else:
            color = Color.RED
        self.remainingLabel.text = text
        self.remainingLabel.SetRGB(*color)

    def UpdateHourFill(self):
        blocksByDay = self.FindBlocksByDay()
        for eachDay, blocks in blocksByDay.iteritems():
            for eachBlock in blocks:
                firstHour = self.hourConts[eachDay][eachBlock[0]]
                firstHourTop = firstHour.absoluteTop
                for idxInBlock, eachHour in enumerate(eachBlock):
                    hourCont = self.hourConts[eachDay][eachHour]
                    hourCont.UpdateFillAlignment(firstHourTop)

    def FindBlocksByDay(self):
        vulnerableHours = self.mySchedule.GetVulnerableHours()
        reinforcementHours = self.mySchedule.GetReinforcementHours()
        markedHoursByDay = defaultdict(set)
        for day, hour in itertoolsext.chain(vulnerableHours, reinforcementHours):
            markedHoursByDay[day].add(hour)

        blocksByDay = {day:self.FindBlocks(sorted(list(hoursSet))) for day, hoursSet in markedHoursByDay.iteritems()}
        return blocksByDay

    def FindBlocks(self, hoursInDay):
        listOfBlocks = []
        for k, g in itertools.groupby(enumerate(hoursInDay), lambda (i, x): i - x):
            listOfBlocks.append(map(itemgetter(1), g))

        return listOfBlocks

    def FindPosForHourBlock(self, day, eachBlock):
        firstHour = eachBlock[0]
        lastHour = eachBlock[-1]
        firstCont = self.hourConts[day][firstHour]
        lastCont = self.hourConts[day][lastHour]
        left = firstCont.absoluteLeft - self.weekContParent.absoluteLeft
        top = firstCont.absoluteTop - self.weekContParent.absoluteTop
        width = firstCont.absoluteRight - firstCont.absoluteLeft
        height = lastCont.absoluteBottom - firstCont.absoluteTop
        pos = (left,
         top,
         width,
         height)
        return pos

    def IsRowWithinSelection(self, hourCont, startY, currentY):
        hourTop = hourCont.absoluteTop - self.weekCont.absoluteTop
        hourHeight = hourCont.absoluteBottom - hourCont.absoluteTop
        if hourTop >= startY and hourTop + hourHeight <= currentY:
            return True
        if hourTop + hourHeight >= startY and hourTop <= currentY:
            return True
        return False

    def IsColumnWithinSelection(self, hourCont, startX, currentX):
        hourLeft = hourCont.absoluteLeft - self.weekCont.absoluteLeft
        hourWidth = hourCont.absoluteRight - hourCont.absoluteLeft
        if hourLeft >= startX and hourLeft + hourWidth <= currentX:
            return True
        if hourLeft + hourWidth >= startX and hourLeft <= currentX:
            return True
        return False

    def IsContWithinSelection(self, hourCont, startX, startY, currentX, currentY):
        isRowInSelection = self.IsRowWithinSelection(hourCont, startY, currentY)
        if not isRowInSelection:
            return False
        isColumnInSelection = self.IsColumnWithinSelection(hourCont, startX, currentX)
        if not isColumnInSelection:
            return False
        return True

    def FindSelected(self, startX, startY, currentX, currentY):
        for dayHour, hourCont in self.GetDayHourIterator():
            isContWithinSelection = self.IsContWithinSelection(hourCont, startX, startY, currentX, currentY)
            if not isContWithinSelection:
                if self.IsSelectedInThisRound(dayHour):
                    self.mySchedule.SetInvulnerable(*dayHour)
                continue
            if uicore.uilib.rightbtn:
                self.mySchedule.SetInvulnerable(*dayHour)
                continue
            if self.previousSchedule.IsVulnerable(*dayHour):
                if self.mySchedule.IsVulnerable(*dayHour) and uicore.uilib.rightbtn:
                    self.mySchedule.SetInvulnerable(*dayHour)
            elif not uicore.uilib.rightbtn:
                self.mySchedule.SetVulnerable(*dayHour)

    def IsSelectedInThisRound(self, dayHour):
        if not self.mySchedule.IsVulnerable(*dayHour):
            return False
        if self.previousSchedule.IsVulnerable(*dayHour):
            return False
        return True

    def ColorBoxes(self):
        for dayHour, hourCont in self.GetDayHourIterator():
            if self.mySchedule.IsVulnerable(*dayHour):
                hourCont.SetHourSelectedState(isSelected=True)
            else:
                hourCont.SetHourSelectedState(isSelected=False)

    def GetDayHourIterator(self):
        for day, hourInfo in self.hourConts.iteritems():
            for hour, hourCont in hourInfo.iteritems():
                yield ((day, hour), hourCont)

    def GetConts(self, contDict):
        allConts = []
        for day, hourInfo in contDict.iteritems():
            for hour, hourCont in hourInfo.iteritems():
                allConts.append(hourCont)

        return allConts

    def _OnResize(self):
        self.UpdateHourFill()
        w = self.weekContParent.absoluteRight - self.weekContParent.absoluteLeft
        h = self.weekContParent.absoluteBottom - self.weekContParent.absoluteTop
        size = min(w, h)
        self.backgroundImage.width = size
        self.backgroundImage.height = size


class VulnerabilitySchedulerWithReinforcement(VulnerabilityScheduler):

    def ColorBoxes(self):
        reinforcementHours = self.mySchedule.GetReinforcementHours()
        for dayHour, hourCont in self.GetDayHourIterator():
            if self.mySchedule.IsVulnerable(*dayHour):
                hourCont.SetHourSelectedState(isSelected=True)
            elif dayHour in reinforcementHours:
                hourCont.SetHourSelectedState(isSelected=True, reinforcement=True)
            else:
                hourCont.SetHourSelectedState(isSelected=False)


class FillBox(Container):
    baseFillColor = (0.5, 0.5, 0.5, 0.1)
    selectedColor = (0.7, 0.6, 0.2, 1.0)
    frameColor = (1.0, 1.0, 1.0, 0.05)
    default_basePadding = (0, 0, 0, 0)
    default_fillPadding = (3, 0, 3, 0)

    def ApplyAttributes(self, attributes):
        Container.ApplyAttributes(self, attributes)
        self.basePadding = attributes.get('basePadding', self.default_basePadding)
        self.fillPadding = attributes.get('fillPadding', self.default_fillPadding)
        self.ConstructFillAndFrame()
        self.baseFill.display = attributes.get('showBaseFill', False)
        self.boxFrame.display = attributes.get('showBoxFrame', True)

    def ConstructFillAndFrame(self):
        self._MakeFill()
        self.baseFill = Fill(bgParent=self, color=self.baseFillColor, padding=self.basePadding)
        self.baseFill.display = False
        self.boxFrame = Frame(bgParent=self, color=self.frameColor)

    def _MakeFill(self):
        self.selectedFill = Fill(bgParent=self, color=self.selectedColor, padding=self.fillPadding)
        self.selectedFill.display = False

    def SetHourSelectedState(self, isSelected, *args):
        self.selectedFill.display = isSelected


class UnallocatedBox(FillBox):
    baseFillColor = (0.5, 0.5, 0.5, 0.3)
    selectedColor = (0.7, 0.6, 0.2, 1.0)
    frameColor = (1.0, 1.0, 1.0, 0.0)
    default_basePadding = (1, 0, 1, 0)
    default_fillPadding = (1, 0, 1, 0)


class HourCont(FillBox):
    default_align = uiconst.TOALL
    default_state = uiconst.UI_NORMAL

    def ApplyAttributes(self, attributes):
        FillBox.ApplyAttributes(self, attributes)
        self.parentMouseDown = attributes.parentMouseDown
        self.hint = attributes.hint
        self.dayHour = attributes.dayHour
        day, hour = self.dayHour

    def OnMouseDown(self, *args):
        self.parentMouseDown(*args)

    def _MakeFill(self):
        self.selectedFill = HatchMarkBase(bgParent=self, padding=self.fillPadding)
        self.selectedFill.display = False

    def UpdateFillAlignment(self, firstHourTop):
        self.selectedFill.AdjustTexture(firstHourTop)


class HourContWithReinforcement(HourCont):
    reinforcementColor = (0.7, 0.6, 0.2, 0.2)

    def SetHourSelectedState(self, isSelected, reinforcement = False):
        HourCont.SetHourSelectedState(self, isSelected)
        if reinforcement:
            color = self.reinforcementColor
        else:
            color = self.selectedColor
        self.selectedFill.SetRGB(*color)


class UnallocatedCont(GridContainer):
    default_align = uiconst.TOALL

    def ApplyAttributes(self, attributes):
        GridContainer.ApplyAttributes(self, attributes)
        requiredHours = attributes.requiredHours
        self.mySchedule = attributes.schedule
        self.boxes = []
        for x in xrange(requiredHours):
            c = UnallocatedBox(parent=self, showBaseFill=True, showBoxFrame=False)
            self.boxes.append(c)

    def Update(self):
        remainingHoursNum = self.mySchedule.Remaining()
        for i, c in enumerate(reversed(self.boxes)):
            if i < remainingHoursNum:
                selectedState = False
            else:
                selectedState = True
            c.SetHourSelectedState(isSelected=selectedState)


class HatchMarkBase(Sprite):
    default_align = uiconst.TOTOP
    default_state = uiconst.UI_DISABLED
    default_tileX = True
    default_tileY = True
    default_texturePath = 'res:/UI/Texture/Classes/StructureDeployment/hatchPattern.png'
    textureSize = 8

    def AdjustTexture(self, firstHourTop):
        distFromTop = self.absoluteTop - firstHourTop
        offset = distFromTop % self.textureSize
        self.texture.srcX = offset
